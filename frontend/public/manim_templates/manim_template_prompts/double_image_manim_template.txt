# Role
你是一位专注于教育内容可视化的 Manim 代码专家。你的任务是将【原始代码】中的逻辑（背景、文字内容、数学公式、图形、动画顺序）无损地迁移到【核心双图模板】中,并调整适当格式和布局，使画面看起来协调且美观。

# Context
我有一个【核心双图模板】（Dual Image Template）。 你需要用它适配【原始代码】中的图片，并为每张图片添加精美的边框（要求最好正好围绕这个图片，显得比较合身）。

- ** 注意！！图片填充逻辑如下 ** ：
1. 如果原始代码中ImageMobject的变量名为bg，**一定不要**将其作为主内容中图片的适配，只要继续作为背景图片即可；

2. (情况 A) 无内容图片：如果【原始代码】中不含除 bg 外的 ImageMobject，则 img_left_path 和 img_right_path 都使用占位路径 "/home/TeachMasterAppV2/backend/placeholder.png"；

3. (情况 B) 只有 1 张图片：如果【原始代码】中除 bg 外只有 1 个 ImageMobject，将其作为左侧图片 (img_left_path)，右侧 (img_right_path) 使用占位路径；

4. (情况 C) 有 2 张及以上图片：则要求全部保留，采取并列式放在画面中心即可。

- ** 注意！！文字填充逻辑如下 ** ：
1. note_left: 如果原始代码中有专门描述第一张图的文字，填入此处；否则填 ""。

2. note_right: 如果原始代码中有专门描述第二张图的文字，填入此处；否则填 ""。

3. footer_text: 如果原始代码中有总结性的描述，填入此处；否则填 ""。

# Input Data
**【核心双图模板】**内容：
from manim import *
import numpy as np

class RefinedDualImageScene(Scene):
    def construct(self):
        # ==========================================
        # 0. 全局配置
        # ==========================================
        FONT_MAIN = "AR PL UKai CN"
        
        # 配色方案 (保持与单图模板一致的品牌色)
        COLOR_ACCENT = "#4AF626"     # 品牌亮绿色
        COLOR_TEXT_MAIN = WHITE
        COLOR_TEXT_SUB = "#CCCCCC"
        COLOR_BORDER_DIM = GREY_B    # 内圈细线
        COLOR_BORDER_LIT = "#4AF626" # 四角高亮

        # ==========================================
        # 1. 舞台搭建 (背景与遮罩)
        # ==========================================
        # [LLM 填空]: 填入背景图路径替换bg (若无特定背景则保持默认)
        try:
            bg = ImageMobject("/home/TeachMasterAppV2/backend/placeholder.png")
            bg.set_z_index(-100)
            bg.scale(max(config.frame_width / bg.width, config.frame_height / bg.height))
            bg.move_to(ORIGIN)
            bg_overlay = Rectangle(
                width=config.frame_width, height=config.frame_height, 
                fill_color=BLACK, fill_opacity=0.6, stroke_width=0
            )
            self.add(bg, bg_overlay)
        except:
            self.camera.background_color = "#1a1a1a"

        # ==========================================
        # 2. 标题栏 (自适应宽度)
        # ==========================================
        # [LLM 填空]: 填入标题
        title_text = "请填入标题内容" 
        
        title = Text(title_text, font=FONT_MAIN, font_size=38, color=COLOR_TEXT_MAIN, weight=BOLD)
        title.to_edge(UP, buff=0.5)
        
        # 线条宽度跟随文字宽度
        line_width = title.width + 1.2
        title_line = Line(LEFT * (line_width / 2), RIGHT * (line_width / 2), color=COLOR_ACCENT)
        title_line.next_to(title, DOWN, buff=0.15)
        title_line.set_stroke(width=2)

        self.play(FadeIn(title, shift=DOWN*0.5), Create(title_line), run_time=1.0)

        # ==========================================
        # 3. 核心双图展示 (Dual Images)
        # ==========================================
        # [LLM 指令]: 替换下方两个图片路径

        image_left = ImageMobject("在此处填入左图路径.png")
        image_right = ImageMobject("在此处填入右图路径.png")

        # --- 布局与缩放逻辑 ---
        # 将两张图放入一个 Group，自动排列
        image_group = Group(image_left, image_right).arrange(RIGHT, buff=1.0)

        # 尺寸限制：确保双图并排不超过屏幕宽度的 85%，高度不超过 4.5
        max_total_width = config.frame_width * 0.85
        max_single_height = 4.5

        # 1. 先限制高度 (防止单张竖图过高)
        if image_left.height > max_single_height:
            image_left.scale(max_single_height / image_left.height)
        if image_right.height > max_single_height:
            image_right.scale(max_single_height / image_right.height)
            
        # 2. 重新排列后，限制整体宽度
        image_group.arrange(RIGHT, buff=1.0) # 重排以更新位置
        if image_group.width > max_total_width:
            scale_factor = max_total_width / image_group.width
            image_group.scale(scale_factor)

        # 3. 整体居中上移 (留出底部文字空间)
        image_group.move_to(ORIGIN).shift(UP * 0.2)

        # --- 边框绘制工厂函数 (保持简约风格) ---
        def create_tech_frame(target_mob):
            padding = 0.15
            w = target_mob.width + padding * 2
            h = target_mob.height + padding * 2
            
            # 内圈细线
            inner = RoundedRectangle(
                corner_radius=0.1, width=w, height=h,
                color=COLOR_BORDER_DIM, stroke_width=1, stroke_opacity=0.5
            ).move_to(target_mob)
            
            # 四角高亮括号
            brackets = VGroup()
            corner_len = min(0.5, w/4, h/4) # 动态调整括号长度，防止小图括号打架
            configs = [
                (inner.get_corner(UL), DOWN, RIGHT),
                (inner.get_corner(UR), DOWN, LEFT),
                (inner.get_corner(DL), UP, RIGHT),
                (inner.get_corner(DR), UP, LEFT)
            ]
            for p, v1, v2 in configs:
                l1 = Line(p, p + v1 * corner_len, color=COLOR_ACCENT, stroke_width=4)
                l2 = Line(p, p + v2 * corner_len, color=COLOR_ACCENT, stroke_width=4)
                brackets.add(l1, l2)
            
            return inner, brackets

        # 为左右图分别生成边框
        frame_l_inner, frame_l_corners = create_tech_frame(image_left)
        frame_r_inner, frame_r_corners = create_tech_frame(image_right)

        # --- 动画 ---
        self.play(
            Create(frame_l_inner), Create(frame_r_inner),
            FadeIn(frame_l_corners, scale=1.1), FadeIn(frame_r_corners, scale=1.1),
            run_time=0.8
        )
        self.play(FadeIn(image_left), FadeIn(image_right), run_time=1.0)

        # ==========================================
        # 4. 底部描述
        # ==========================================
        # [LLM 填空]: 填入描述
        description_text = "在此处填入描述文字"
        
        footer = Text(
            description_text, 
            font=FONT_MAIN, 
            font_size=24, 
            line_spacing=1.2,
            color=COLOR_TEXT_SUB
        )
        footer.to_edge(DOWN, buff=1.2)

        self.play(Write(footer), run_time=1.5)

        self.wait(3)