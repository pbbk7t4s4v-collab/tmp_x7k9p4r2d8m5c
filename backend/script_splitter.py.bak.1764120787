#!/usr/bin/env python3
"""
讲义分割器：将生成的Markdown讲义按照##标题分割成多个文件
"""

import argparse
import os
import re
from pathlib import Path


class ScriptSplitter:
    """讲义分割器类"""
    
    def __init__(self, verbose=False):
        self.verbose = verbose
    
    def read_markdown_file(self, filepath):
        """读取Markdown文件内容"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            return content
        except FileNotFoundError:
            raise FileNotFoundError(f"找不到文件: {filepath}")
        except Exception as e:
            raise Exception(f"读取文件时出错: {e}")
    
    def split_by_headers(self, content):
        """按照##标题分割内容"""
        # 使用正则表达式找到所有##标题的位置
        pattern = r'^## (.+)$'
        lines = content.split('\n')
        
        sections = []
        current_section = {
            'title': '',
            'content': '',
            'start_line': 0
        }
        
        for i, line in enumerate(lines):
            match = re.match(pattern, line)
            
            if match:  # 找到了##标题
                # 如果当前section有内容，保存它
                if current_section['title'] or current_section['content'].strip():
                    sections.append(current_section.copy())
                
                # 开始新的section
                current_section = {
                    'title': match.group(1).strip(),
                    'content': line + '\n',
                    'start_line': i
                }
            else:
                # 添加到当前section
                current_section['content'] += line + '\n'
        
        # 添加最后一个section
        if current_section['title'] or current_section['content'].strip():
            sections.append(current_section)
        
        return sections
    
    
    def save_sections(self, sections, output_path):
        """保存分割后的章节到文件"""
        saved_files = []
        
        for i, section in enumerate(sections, 1):
            # 创建文件名
            filename = f"{i}.md"
            filepath = os.path.join(output_path, filename)
            
            # 保存文件
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(section['content'])
            
            saved_files.append({
                'filename': filename,
                'filepath': str(filepath),
                'title': section['title'],
                'lines': len(section['content'].split('\n'))
            })
        
        # 删除第一个文件并重命名后续文件
        saved_files = self._remove_first_and_rename(output_path, saved_files)
        
        # 创建章节标题文件
        self._create_chapter_list(output_path, saved_files)
        
        return saved_files
    
    def _remove_first_and_rename(self, output_path, saved_files):
        """删除第一个文件（1.md）并将后续文件重命名"""
        if len(saved_files) <= 1:
            # 如果只有一个或没有文件，直接返回
            return saved_files
        
        # 删除第一个文件（1.md）
        first_file_path = os.path.join(output_path, "1.md")
        if os.path.exists(first_file_path):
            os.remove(first_file_path)
        
        # 重命名后续文件：2.md -> 1.md, 3.md -> 2.md, ...
        new_saved_files = []
        for i, file_info in enumerate(saved_files[1:], 1):  # 从第二个文件开始
            old_filepath = Path(file_info['filepath'])
            new_filename = f"{i}.md"
            new_filepath = os.path.join(output_path, new_filename)
            
            # 重命名文件
            if old_filepath.exists():
                old_filepath.rename(new_filepath)
            
            # 更新文件信息
            new_saved_files.append({
                'filename': new_filename,
                'filepath': str(new_filepath),
                'title': file_info['title'],
                'lines': file_info['lines']
            })
        
        return new_saved_files
    
    def _create_chapter_list(self, output_path, saved_files):
        """创建章节标题列表文件"""
        chapter_list_path = os.path.join(output_path, "chapter.txt")
        
        with open(chapter_list_path, 'w', encoding='utf-8') as f:
            for i, file_info in enumerate(saved_files, 1):
                title = file_info['title'] if file_info['title'] else f"章节{i}"
                # 清理标题中的markdown格式符号
                clean_title = title.replace('**', '').replace('*', '').strip()
                f.write(f"{i}.{clean_title}\n")
    
    def split_script(self, input_file, output_dir="scripts", page=0):
        """
        分割讲义脚本的主要方法
        
        Args:
            input_file: 输入的Markdown文件路径
            output_dir: 输出目录
            verbose: 是否显示详细信息
        
        Returns:
            保存的文件信息列表
        """
        if self.verbose:
            print(f"正在分割文件: {input_file}")
            print("="*60)
        
        # 1. 读取文件
        content = self.read_markdown_file(input_file)
        if self.verbose:
            print(f"✓ 文件读取完成，共 {len(content.split())} 行")
        
        # 2. 按##标题分割
        sections = self.split_by_headers(content)
        if self.verbose:
            print(f"✓ 找到 {len(sections)} 个章节")
        
        # 3. 创建输出目录
        os.makedirs(output_dir, exist_ok=True)
        if self.verbose:
            print(f"✓ 创建输出目录: {output_dir}")
        
        # 4. 保存分割后的文件
        saved_files = self.save_sections(sections, output_dir)

        # 根据传入的page字段决定生成的page数量,page为0时不限制
        if page > 0:
            saved_files = saved_files[:page]
        
        if self.verbose:
            print(f"✓ 保存分割后的文件")
            if len(sections) > 1:
                print(f"✓ 删除第一个文件（课程大纲）并重新编号")
            print(f"✓ 创建章节标题列表文件 (chapter.txt)")
            print(f"✓ 分割完成！共保存 {len(saved_files)} 个章节文件 + 1个标题列表文件")
            print("\n分割结果:")
            print("-"*60)
            for file_info in saved_files:
                title = file_info['title'] if file_info['title'] else "（无标题）"
                print(f"{file_info['filename']}: {title}")
                print(f"  路径: {file_info['filepath']}")
                print(f"  行数: {file_info['lines']}")
                print()
            
            # 显示chapter.txt文件信息
            chapter_file = os.path.join(output_dir, "chapter.txt")
            print(f"chapter.txt: 章节标题列表")
            print(f"  路径: {chapter_file}")
        
        return saved_files
    
    def pipeline(self, input_file, output_dir="scripts/splitted", page=0):
        """简化的流水线接口"""
        script_splitted_files = self.split_script(input_file, output_dir=output_dir, page=page)
        return output_dir


def main():
    """主函数"""
    parser = argparse.ArgumentParser(
        description="讲义分割器 - 将Markdown讲义按##标题分割成多个文件",
        epilog="示例: python script_splitter.py scripts/KNN_8813.md"
    )
    parser.add_argument(
        "input_file",
        help="要分割的Markdown文件路径"
    )
    parser.add_argument(
        "--output-dir",
        type=str,
        default="scripts",
        help="输出目录 (默认: scripts)"
    )
    parser.add_argument(
        "--quiet",
        action="store_true",
        help="静默模式，不显示过程信息"
    )
    
    args = parser.parse_args()
    
    try:
        # 检查输入文件是否存在
        if not os.path.exists(args.input_file):
            print(f"错误: 文件 '{args.input_file}' 不存在")
            return
        
        # 创建分割器并执行分割
        splitter = ScriptSplitter()
        saved_files = splitter.split_script(
            args.input_file,
            output_dir=args.output_dir,
            verbose=not args.quiet
        )
        
        if not args.quiet:
            print("分割完成！所有章节文件和标题列表 (chapter.txt) 已保存。")
        
    except Exception as e:
        print(f"错误: {e}")
        print("\n请确保:")
        print("1. 输入文件路径正确")
        print("2. 文件格式为Markdown (.md)")
        print("3. 文件包含##级别的标题")


if __name__ == "__main__":
    main()