#!/usr/bin/env python3
"""
Markdown切割器：将分页后的markdown文件按分页标记切割成独立文件
根据 <!-- PAGE_BREAK --> 标记将 *_paginated.md 文件切割成 *_1.md, *_2.md 等
"""

import argparse
import os
import glob
import re


class MarkdownSplitter:
    """Markdown文件切割器"""
    
    def __init__(self, verbose=False):
        self.verbose = verbose
        self.page_break_pattern = re.compile(r'<!--\s*PAGE_BREAK\s*-->', re.IGNORECASE)
    
    def split_markdown_file(self, file_path, verbose=False):
        """
        切割单个markdown文件
        
        Args:
            file_path: _paginated.md文件路径
            verbose: 是否显示详细过程
        
        Returns:
            切割结果信息
        """
        try:
            # 读取文件内容
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            if verbose:
                print(f"正在处理文件: {file_path}")
                print(f"文件大小: {len(content)} 字符")
            
            # 按分页标记分割内容
            pages = self.page_break_pattern.split(content)
            
            # 清理空白页面
            pages = [page.strip() for page in pages if page.strip()]
            
            if verbose:
                print(f"分割成 {len(pages)} 个页面")
            
            # 生成输出文件名前缀
            dir_name = os.path.dirname(file_path)
            base_name = os.path.basename(file_path)
            
            # 移除 _paginated.md 后缀
            if base_name.endswith('_paginated.md'):
                prefix = base_name[:-13]  # 移除 '_paginated.md'
            else:
                prefix = os.path.splitext(base_name)[0]
            
            # 保存分割后的文件
            saved_files = []
            for i, page_content in enumerate(pages, 1):
                output_filename = f"{prefix}_{i}.md"
                output_path = os.path.join(dir_name, output_filename)
                
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(page_content)
                
                saved_files.append(output_path)
                
                if verbose:
                    print(f"  页面 {i}: {output_path} ({len(page_content)} 字符)")
            
            return {
                'original_file': file_path,
                'pages_count': len(pages),
                'saved_files': saved_files,
                'status': 'success'
            }
            
        except Exception as e:
            print(f"处理文件 {file_path} 时出错: {e}")
            return {
                'original_file': file_path,
                'pages_count': 0,
                'saved_files': [],
                'status': 'failed',
                'error': str(e)
            }
    
    def process_directory(self, directory_path, verbose=True):
        """
        处理目录中的所有 _paginated.md 文件
        
        Args:
            directory_path: 目录路径
            verbose: 是否显示详细过程
        
        Returns:
            处理结果统计
        """
        if not os.path.exists(directory_path):
            print(f"目录不存在: {directory_path}")
            return None
        
        # 查找所有 _paginated.md 文件
        pattern = os.path.join(directory_path, "*_paginated.md")
        paginated_files = glob.glob(pattern)
        
        if not paginated_files:
            print(f"在目录 {directory_path} 中未找到 *_paginated.md 文件")
            return None
        
        if verbose:
            print(f"找到 {len(paginated_files)} 个分页文件")
            print("="*50)
        
        results = {
            'total_files': len(paginated_files),
            'success_files': 0,
            'failed_files': 0,
            'total_pages': 0,
            'details': []
        }
        
        # 逐个处理文件
        for i, paginated_file in enumerate(sorted(paginated_files), 1):
            if verbose:
                print(f"\n[{i}/{len(paginated_files)}] 处理: {os.path.basename(paginated_file)}")
            
            # 切割文件
            result = self.split_markdown_file(paginated_file, verbose=verbose)
            results['details'].append(result)
            
            if result['status'] == 'success':
                results['success_files'] += 1
                results['total_pages'] += result['pages_count']
            else:
                results['failed_files'] += 1
        
        return results
    
    def print_summary(self, results):
        """打印处理结果摘要"""
        if not results:
            return
        
        print("\n" + "="*50)
        print("文件切割完成!")
        print(f"总计文件: {results['total_files']}")
        print(f"成功处理: {results['success_files']}")
        print(f"处理失败: {results['failed_files']}")
        print(f"生成页面: {results['total_pages']}")
        
        # 显示成功处理的文件详情
        success_details = [d for d in results['details'] if d['status'] == 'success']
        if success_details:
            print("\n成功处理的文件:")
            for detail in success_details:
                original_name = os.path.basename(detail['original_file'])
                print(f"  {original_name} -> {detail['pages_count']} 个页面")
                for saved_file in detail['saved_files']:
                    print(f"    {os.path.basename(saved_file)}")
        
        # 显示失败的文件
        failed_details = [d for d in results['details'] if d['status'] == 'failed']
        if failed_details:
            print("\n处理失败的文件:")
            for detail in failed_details:
                print(f"  {os.path.basename(detail['original_file'])}: {detail.get('error', '未知错误')}")
    
    def clean_split_files(self, directory_path, verbose=True):
        """
        清理之前切割产生的文件（可选功能）
        
        Args:
            directory_path: 目录路径
            verbose: 是否显示详细过程
        """
        # 查找所有 *_数字.md 格式的文件
        pattern = os.path.join(directory_path, "*_[0-9]*.md")
        split_files = glob.glob(pattern)
        
        if not split_files:
            if verbose:
                print("没有找到需要清理的切割文件")
            return
        
        if verbose:
            print(f"找到 {len(split_files)} 个切割文件，准备清理...")
        
        for file_path in split_files:
            try:
                os.remove(file_path)
                if verbose:
                    print(f"已删除: {os.path.basename(file_path)}")
            except Exception as e:
                print(f"删除文件 {file_path} 时出错: {e}")

    def pipeline(self, directory_path, clean=True, verbose=True):
        """
        简化的流水线接口
        
        Args:
            directory_path: 目录路径
            verbose: 是否显示详细过程
        
        Returns:
            处理结果统计
        """
        if clean:
            self.clean_split_files(directory_path, verbose=verbose)
        return self.process_directory(directory_path, verbose=verbose)


def main():
    """主函数"""
    parser = argparse.ArgumentParser(
        description="Markdown切割器 - 将分页文件按分页标记切割成独立页面",
        epilog="示例: python splitter.py scripts/KNN_5288_sections/"
    )
    parser.add_argument(
        "directory",
        help="包含 *_paginated.md 文件的目录路径"
    )
    parser.add_argument(
        "--clean",
        action="store_true",
        help="在处理前清理目录中已存在的切割文件"
    )
    parser.add_argument(
        "--quiet",
        action="store_true",
        help="静默模式，只显示结果摘要"
    )
    
    args = parser.parse_args()
    
    try:
        # 创建切割器
        splitter = MarkdownSplitter()
        
        # 清理旧文件（如果指定）
        if args.clean:
            splitter.clean_split_files(args.directory, verbose=not args.quiet)
        
        # 处理目录
        results = splitter.process_directory(args.directory, verbose=not args.quiet)
        
        # 显示结果摘要
        splitter.print_summary(results)
        
    except Exception as e:
        print(f"错误: {e}")
        print("\n请确保:")
        print("1. 目录路径正确")
        print("2. 目录中包含 *_paginated.md 文件")
        print("3. 有足够的文件读写权限")


if __name__ == "__main__":
    main()